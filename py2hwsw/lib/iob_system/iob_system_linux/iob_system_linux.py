# SPDX-FileCopyrightText: 2025 IObundle
#
# SPDX-License-Identifier: MIT

import os
import sys
import shutil

# Add iob-system scripts folder to python path
sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), "../scripts"))

from iob_system_utils import update_params


def setup(py_params_dict):
    params = {
        "dma_demo": False,
    }
    iob_system_default_params = {
        "use_intmem": False,
        "use_extmem": True,
        "mem_addr_w": 17,  # FIXME: Temprorary lower value for speed up. Change to 26 for Linux.
        "bootrom_addr_w": 15,
        "fw_baseaddr": 0,
    }
    iob_system_default_params |= {
        "fw_addr_w": iob_system_default_params["mem_addr_w"],
    }
    # Update parameters values with ones given in python parameters
    update_params(params, py_params_dict)

    # py_params_dict will be passed to iob_system. Merge with new default parameters.
    py_params_dict = {**iob_system_default_params, **py_params_dict}

    #
    # Verilog snippets
    #
    verilog_snippet = """
   assign interrupts = {{30{1'b0}}, uart_interrupt, 1'b0};
"""

    if params["dma_demo"]:
        verilog_snippet += """
   assign AXISTREAMIN0_axis_clk_i = clk_i;
   assign AXISTREAMIN0_axis_cke_i = cke_i;
   assign AXISTREAMIN0_axis_arst_i = arst_i;
   assign AXISTREAMOUT0_axis_clk_i = clk_i;
   assign AXISTREAMOUT0_axis_cke_i = cke_i;
   assign AXISTREAMOUT0_axis_arst_i = arst_i;
"""

    #
    # Post-processing
    #

    #     dst = f"{cls.build_dir}/software/src"
    #     src = f"{__class__.setup_dir}/submodules/OS/software/OS_build"
    #     files = ["rootfs.cpio.gz", "Image"]
    #     for fname in files:
    #         src_file = os.path.join(src, fname)
    #         if os.path.isfile(src_file):
    #             shutil.copy2(src_file, dst)
    #
    #     super()._post_setup()
    #
    #     # Copy scripts to scripts build directory
    if py_params_dict["build_dir"]:
        for src_file in [
            "scripts/check_if_run_linux.py",
        ]:
            src = os.path.join(os.path.dirname(__file__), src_file)
            dst = os.path.join(py_params_dict["build_dir"], src_file)
            os.makedirs(os.path.dirname(dst), exist_ok=True)
            shutil.copy2(src, dst)
    #     iob_soc_scripts = [
    #         "terminalMode",
    #         "makehex",
    #         "hex_split",
    #         "hex_join",
    #         "board_client",
    #         "console",
    #         "console_ethernet",
    #     ]
    #     dst = f"{cls.build_dir}/scripts"
    #     for script in iob_soc_scripts:
    #         src_file = f"{__class__.setup_dir}/submodules/IOBSOC/scripts/{script}.py"
    #         shutil.copy2(src_file, dst)
    #     src_file = f"{__class__.setup_dir}/scripts/check_if_run_linux.py"
    #     shutil.copy2(src_file, dst)
    #
    #     shutil.copy2(
    #         f"{__class__.setup_dir}/software/versat/module/versat.ko",
    #         f"{cls.build_dir}/software",
    #     )
    #     shutil.copy2(
    #         f"{__class__.setup_dir}/software/tests/exampleTransfer.sh",
    #         f"{cls.build_dir}/software",
    #     )
    #     shutil.copy2(
    #         f"{__class__.setup_dir}/software/tests/setupTest.sh",
    #         f"{cls.build_dir}/software",
    #     )
    #     shutil.copy2(
    #         f"{__class__.setup_dir}/software/tests/test.sh",
    #         f"{cls.build_dir}/software",
    #     )
    #
    #     shutil.copytree(
    #         f"{__class__.setup_dir}/hardware/src/units",
    #         f"{cls.build_dir}/hardware/src",
    #         dirs_exist_ok=True,
    #     )
    #
    #     # Override periphs_tmp.h of iob-soc with one specific for linux
    #     create_periphs_tmp(
    #         cls.name,
    #         next(i["val"] for i in cls.confs if i["name"] == "ADDR_W"),
    #         cls.peripherals,
    #         f"{cls.build_dir}/software/{cls.name}_periphs.h",
    #     )
    #     check_linux_build_macros(cls, f"{__class__.setup_dir}/submodules/OS")
    #
    #     if cls.is_top_module:
    #         # Set variables in fpga_build.mk
    #         with open(cls.build_dir + "/hardware/fpga/fpga_build.mk", "r") as file:
    #             contents = file.readlines()
    #         contents.append(
    #             "#Lines below were auto generated by iob_system_linux.py\n"
    #         )
    #         # Set custom ethernet CONSOLE_CMD
    #         contents.append(
    #                 f"""
    # RUN_DEPS+=boot_flow
    # GRAB_TIMEOUT = 1200
    # ### Launch minicom if running Linux
    # # pass CI variable over ssh commands
    # UFLAGS+=CI=$(CI)
    # UFLAGS+=BOOT_FLOW=$(BOOT_FLOW)
    # ifeq ($(shell grep -o rootfs.cpio.gz ../{cls.name}_mem.config),rootfs.cpio.gz)
    # ifneq ($(wildcard minicom_linux_script.txt),)
    # SCRIPT_STR:=-S minicom_linux_script.txt
    # # Set TERM variable to linux-c-nc (needed to run in non-interactive mode https://stackoverflow.com/a/49077622)
    # TERM_STR:=TERM=linux-c-nc
    # # Give fake stdout to minicom on CI (continuous integration), as it does not have any available (based on https://www.linuxquestions.org/questions/linux-general-1/capuring-data-with-minicom-over-tty-interface-4175558631/#post5448734)
    # # Run minicom process in background for Github Actions and wait for minicom to
    # # finish so that board_client does not finish as soon as minicom goes to
    # # background
    # # Github Actions sets CI="true" (https://docs.github.com/en/actions/learn-github-actions/variables#default-environment-variables)
    # ifneq ($(CI),)
    # FAKE_STDOUT:=> minicom2.log
    # RUN_MINICOM_IN_BACKGROUND:= & wait $$!
    # else
    # FAKE_STDOUT:=
    # RUN_MINICOM_IN_BACKGROUND:=
    # endif
    # endif
    # # Set a capture file and print its contents (to work around minicom clearing the screen)
    # LOG_STR:=-C minicom_out.log $(FAKE_STDOUT) || cat minicom_out.log
    # # Set HOME to current (fpga) directory (needed because minicom always reads the '.minirc.*' config file from HOME)
    # HOME_STR:=HOME=$$(pwd)
    # # Always exit with code 0 (since linux is terminated with CTRL-C)
    # CONSOLE_CMD += && (($(HOME_STR) $(TERM_STR) minicom iobundle.dfl $(SCRIPT_STR) $(LOG_STR) || (exit 0)) $(RUN_MINICOM_IN_BACKGROUND) )
    # endif
    # """
    #         )
    #         with open(cls.build_dir + "/hardware/fpga/fpga_build.mk", "w") as file:
    #             file.writelines(contents)
    #
    #         # Set ETH_IF in sim_build.mk
    #         with open(cls.build_dir + "/hardware/simulation/sim_build.mk", "r") as file:
    #             contents = file.readlines()
    #
    #         contents.insert(0, "\n")
    #         contents.insert(
    #             0,
    #             """
    # #Lines below were auto generated by iob_system_linux.py
    # ETH_IF ?= eth-$(SIMULATOR)
    # """,
    #         )
    #         with open(cls.build_dir + "/hardware/simulation/sim_build.mk", "w") as file:
    #             file.writelines(contents)
    #
    #         # Set ethernet MAC address in config_build.mk
    #         append_str_config_build_mk(
    #                 f"""
    # ### Set Ethernet environment variables
    # #Eth interface address of pc connected to ethernet peripheral (based on board name)
    # $(if $(findstring sim,$(MAKECMDGOALS))$(SIMULATOR),$(eval BOARD=))
    # ifeq ($(BOARD),AES-KU040-DB-G)
    # ETH_IF ?=eno1
    # endif
    # ifeq ($(BOARD),CYCLONEV-GT-DK)
    # ETH_IF ?= enp0s31f6
    # endif
    # # Set a MAC address for console (randomly generated)
    # RMAC_ADDR ?=88431eafa897
    # export RMAC_ADDR
    # #Set correct environment if running on IObundle machines
    # ifneq ($(filter feynman pudim-flan sericaia,$(shell hostname)),)
    # IOB_CONSOLE_PYTHON_ENV ?= /opt/pyeth3/bin/python
    # else
    # IOB_CONSOLE_PYTHON_ENV ?= {__class__.setup_dir}/submodules/ETHERNET/scripts/pyRawWrapper/pyRawWrapper
    # endif
    #                     """,
    #                 cls.build_dir,
    #             )

    #
    # Versat
    #

    # VERSAT_SPEC = f"{__class__.setup_dir}/software/versat/versatSpec.txt"
    # VERSAT_EXTRA_UNITS = os.path.realpath(
    #     os.path.join(os.path.dirname(__file__), "hardware/src/units")
    # )

    # cls.versatType = CreateVersatClass(
    #     False, VERSAT_SPEC, "CryptoAlgos", VERSAT_EXTRA_UNITS, cls.build_dir
    # )

    #
    # IOb-System-Linux core dictionary
    #
    core_dict = {
        "version": "0.8",
        "parent": {
            # IOb-System-Linux is a child core of iob_system: https://github.com/IObundle/py2hwsw/tree/main/py2hwsw/lib/hardware/iob_system
            # IOb-System-Linux will inherit all attributes/files from the iob_system core.
            "core_name": "iob_system",
            # Every parameter in the lines below will be passed to the iob_system parent core.
            # Full list of parameters availabe here: https://github.com/IObundle/py2hwsw/blob/main/py2hwsw/lib/iob_system/iob_system.py
            "cpu": "iob_vexriscv",
            # Don't include iob_system's snippets. We will use our own.
            "include_snippets": False,
            # NOTE: Place other iob_system python parameters here
            "system_attributes": {
                # Every attribute in this dictionary will override/append to the ones of the iob_system parent core.
                "board_list": [
                    "iob_aes_ku040_db_g",
                    "iob_cyclonev_gt_dk",
                    "iob_zybo_z7",
                ],
                "confs": [
                    {
                        "name": "N_CORES",
                        "descr": "Number of CPU cores used in the SoC.",
                        "type": "P",
                        "val": "1",
                        "min": "1",
                        "max": "32",
                    },
                    {  # For iob_spi_master
                        "name": "FPGA_TOOL",
                        "descr": "Use IPs from fpga tool. Avaliable options: 'XILINX', 'other'.",
                        "type": "P",
                        "val": '"other"',
                        "min": "NA",
                        "max": "NA",
                    },
                    # Old opencrytolinux confs. Are they still needed?
                    # { # Used for software.
                    #     "name": "OS_ADDR_W",
                    #     "descr": "Linux OS address width",
                    #     "type": "M",
                    #     "val": "25",
                    #     "min": "1",
                    #     "max": "32",
                    # },
                    # {
                    #     "name": "N_SOURCES",
                    #     "type": "P",
                    #     "val": "32",
                    #     "min": "1",
                    #     "max": "32",
                    #     "descr": "Number of peripherals that can generate an external interrupt to be interpreted by the PLIC.",
                    # },
                    # {
                    #     "name": "N_TARGETS",
                    #     "type": "P",
                    #     "val": "2",
                    #     "min": "1",
                    #     "max": "32",
                    #     "descr": "Number of HARTs in the SoC.",
                    # },
                    # {
                    #     "name": "DMA_DEMO",
                    #     "type": "M",
                    #     "val": True,
                    #     "min": "0",
                    #     "max": "1",
                    #     "descr": "Enable DMA demo",
                    # },
                ],
                "ports": [
                    {
                        # Add new rs232 port for uart
                        "name": "rs232_m",
                        "descr": "iob-system uart interface",
                        "signals": {
                            "type": "rs232",
                        },
                    },
                    # NOTE: Add other ports here.
                ],
                "wires": [
                    # UART
                    {
                        "name": "uart_interrupt",
                        "descr": "Uart interrupt",
                        "signals": [
                            {"name": "uart_interrupt", "width": 1},
                        ],
                    },
                    # SPI master
                    # {
                    #     "name": "spi_cache",
                    #     "descr": "SPI cache bus",
                    #     "if_defined": "RUN_FLASH",
                    #     "signals": {
                    #         "type": "iob",
                    #         "prefix": "spi_",
                    #     },
                    # },
                    {
                        "name": "spi_flash",
                        "descr": "SPI flash bus",
                        "signals": [
                            {"name": "ss", "width": 1},
                            {"name": "sclk", "width": 1},
                            {"name": "miso", "width": 1},
                            {"name": "mosi", "width": 1},
                            {"name": "wp_n", "width": 1},
                            {"name": "hold_n", "width": 1},
                        ],
                    },
                ],
                "subblocks": [
                    {
                        # Instantiate a UART16550 core from: https://github.com/IObundle/iob-uart16550
                        "core_name": "iob_uart16550",
                        "instance_name": "UART0",  # Use same name as one inherited from iob_system to replace it
                        "instance_description": "UART peripheral",
                        "is_peripheral": True,
                        "parameters": {},
                        "connect": {
                            "clk_en_rst_s": "clk_en_rst_s",
                            # Cbus connected automatically
                            "rs232_m": "rs232_m",
                            "interrupt_o": "uart_interrupt",
                        },
                    },
                    # {
                    #     "core_name": "iob_eth",
                    #     "instance_name": "ETH0",
                    #     "instance_description": "Ethernet interface",
                    #     "peripheral_addr_w": 12,
                    #     "parameters": {
                    #         "AXI_ID_W": "AXI_ID_W",
                    #         "AXI_LEN_W": "AXI_LEN_W",
                    #         "AXI_ADDR_W": params["addr_w"],
                    #         "AXI_DATA_W": params["data_w"],
                    #     },
                    #     "connect": {
                    #         "clk_en_rst_s": "clk_en_rst_s",
                    #         "axi_m": (
                    #             "eth_axi",
                    #             [
                    #                 "eth_axi_arid[0]",
                    #                 "eth_axi_rid[0]",
                    #                 "eth_axi_awid[0]",
                    #                 "eth_axi_bid[0]",
                    #             ],
                    #         ),
                    #         "inta_o": "ethernet_interrupt",
                    #         "phy_io": "phy_io",
                    #     },
                    # },
                    # {
                    #     # Instantiate a VERSAT core from: https://github.com/IObundle/iob-versat
                    #     "core_name": "iob_versat",
                    #     "instance_name": "VERSAT0",
                    #     "instance_description": "VERSAT accelerator",
                    #     "is_peripheral": True,
                    #     "parameters": {},
                    #     "connect": {
                    #         "clk_en_rst_s": "clk_en_rst_s",
                    #         # Cbus connected automatically
                    #         # TODO:
                    #     },
                    # },
                    {
                        # Instantiate a SPI master core from: https://github.com/IObundle/iob-spi
                        "core_name": "iob_spi_master",
                        "instance_name": "SPI",
                        "instance_description": "SPI master peripheral",
                        "is_peripheral": True,
                        "parameters": {
                            "FPGA_TOOL": "FPGA_TOOL",
                        },
                        "connect": {
                            "clk_en_rst_s": "clk_en_rst_s",
                            # Cbus connected automatically
                            # "cache_iob_s": "spi_cache",
                            "flash_io": "spi_flash",
                        },
                    },
                    #
                    # Peripherals for DMA demo
                    # {
                    #     "core_name": "iob_axistream_in",
                    #     "instance_name": "AXISTREAMIN0",
                    #     "instance_description": "AXI-Stream input interface",
                    #     "parameters": {
                    #         "TDATA_W": "32",
                    #         "FIFO_ADDR_W": "4",
                    #     },
                    #     "connect": {
                    #         "clk_en_rst_s": "clk_en_rst_s",
                    #         "interrupt_o": "axistream_in_interrupt",
                    #         "axistream_io": "axistream_in_axis", # AXI-Stream in and out should be connected in loopback for demo
                    #         "sys_axis_io": "dma_axis_in",
                    #         "iob_csrs_cbus_s": "axistream_in_csrs",
                    #     },
                    # },
                    # {
                    #     "core_name": "iob_axistream_out",
                    #     "instance_name": "AXISTREAMOUT0",
                    #     "instance_description": "AXI-Stream output interface",
                    #     "parameters": {
                    #         "TDATA_W": "32",
                    #         "FIFO_ADDR_W": "4",
                    #     },
                    #     "connect": {
                    #         "clk_en_rst_s": "clk_en_rst_s",
                    #         "interrupt_o": "axistream_out_interrupt",
                    #         "axistream_io": "axistream_out_axis",
                    #         "sys_axis_io": "dma_axis_out",
                    #         "iob_csrs_cbus_s": "axistream_out_csrs",
                    #     },
                    # },
                    # {
                    #     "core_name": "iob_dma",
                    #     "instance_name": "DMA0",
                    #     "instance_description": "DMA interface",
                    #     "parameters": {
                    #         "AXI_ID_W": "AXI_ID_W",
                    #         "AXI_LEN_W": "AXI_LEN_W",
                    #         "AXI_ADDR_W": "AXI_ADDR_W",
                    #         "N_INPUTS": "1",
                    #         "N_OUTPUTS": "1",
                    #     },
                    #     "connect": {
                    #         "clk_en_rst_s": "clk_en_rst_s",
                    #     },
                    # },
                    # NOTE: Add other components/peripherals here.
                ],
                "snippets": [{"verilog_code": verilog_snippet}],
            },
            **py_params_dict,
        },
    }

    return core_dict
