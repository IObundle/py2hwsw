import os
import sys


def create_dts_file(path, peripheral):
    """Create device tree file with demo on how to include the peripheral in the device tree"""
    content = f"""// SPDX-FileCopyrightText: {peripheral['spdx_year']} {peripheral['author']}
//
// SPDX-License-Identifier: {peripheral['spdx_license']}


/dts-v1/;

/ {{
    #address-cells = <1>;
    #size-cells = <1>;
    model = \"IOb-SoC, VexRiscv\";
    compatible = \"IOb-SoC, VexRiscv\";
    // CPU
    // Memory
    // Choosen
    soc {{
        #address-cells = <1>;
        #size-cells = <1>;
        compatible = \"iobundle,iob-soc\", \"simple-bus\";
        ranges;

        // Other SOC peripherals go here

        // Add this Node to device tree
        {peripheral['instance_name'].upper()}: {peripheral['name']}@/*{peripheral['instance_name'].upper()}_ADDR_MACRO*/ {{
            compatible = \"iobundle,{peripheral['instance_name']}\";
            reg = <0x/*{peripheral['instance_name'].upper()}_ADDR_MACRO*/ 0x100>;
        }};

    }};
}};"""
    with open(os.path.join(path, f"{peripheral['name']}.dts"), "w") as f:
        f.write(content)


def create_readme_file(path, peripheral):
    """Create README with directory structure and file descriptions of generated device driver files"""
    content = f"""<!--
SPDX-FileCopyrightText: {peripheral['spdx_year']} {peripheral['author']}

SPDX-License-Identifier: {peripheral['spdx_license']}
-->

# {peripheral['upper_name']} Linux Kernel Drivers
- Structure:
    - `drivers/`: directory with linux kernel module drivers for {peripheral['name']}
        - `{peripheral['name']}_main.c`: driver source
        - `[{peripheral['name']}.h]` and `[{peripheral['name']}_sysfs.h]`: header files generated by:
        ```bash
        python3 .path/to/iob-linux/scripts/drivers.py {peripheral['name']} -o [output_dir]
        ```
        - `driver.mk`: makefile segment with `{peripheral['name']}-obj:` target for driver
          compilation
    - `user/`: directory with user application example that uses {peripheral['name']}
      drivers
        - `{peripheral['name']}_user.c`: example user application that uses {peripheral['name']}
          drivers
        - `Makefile`: user application compilation targets
    - `{peripheral['name']}.dts`: device tree template with {peripheral['name']} node
        - manually add the `timer` node to the system device tree so the
          {peripheral['name']} is recognized by the linux kernel
"""
    with open(os.path.join(path, "README.md"), "w") as f:
        f.write(content)


def create_driver_mk_file(path, peripheral):
    """Create Makefile segment for driver compilation"""
    content = f"""# SPDX-FileCopyrightText: {peripheral['spdx_year']} {peripheral['author']}
#
# SPDX-License-Identifier: {peripheral['spdx_license']}

{peripheral['name']}-objs := {peripheral['name']}_main.o iob_class/iob_class_utils.o
"""
    with open(os.path.join(path, "driver.mk"), "w") as f:
        f.write(content)


def create_driver_main_file(path, peripheral):
    """Create the driver's kernel source"""
    content = f"""/*
 * SPDX-FileCopyrightText: {peripheral['spdx_year']} {peripheral['author']}
 *
 * SPDX-License-Identifier: {peripheral['spdx_license']}
 */

/* {peripheral['name']}_main.c: driver for {peripheral['name']}
 * using device platform. No hardcoded hardware address:
 * 1. load driver: insmod {peripheral['name']}.ko
 * 2. run user app: ./user/user
 */

#include <linux/cdev.h>
#include <linux/fs.h>
#include <linux/io.h>
#include <linux/ioport.h>
#include <linux/kernel.h>
#include <linux/mod_devicetable.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/uaccess.h>

#include "iob_class/iob_class_utils.h"
#include "{peripheral['name']}.h"

static int {peripheral['name']}_probe(struct platform_device *);
static int {peripheral['name']}_remove(struct platform_device *);

static ssize_t {peripheral['name']}_read(struct file *, char __user *, size_t, loff_t *);
static ssize_t {peripheral['name']}_write(struct file *, const char __user *, size_t,
                               loff_t *);
static loff_t {peripheral['name']}_llseek(struct file *, loff_t, int);
static int {peripheral['name']}_open(struct inode *, struct file *);
static int {peripheral['name']}_release(struct inode *, struct file *);

static struct iob_data {peripheral['name']}_data = {{0}};
DEFINE_MUTEX({peripheral['name']}_mutex);

#include "{peripheral['name']}_sysfs.h"

static const struct file_operations {peripheral['name']}_fops = {{
    .owner = THIS_MODULE,
    .write = {peripheral['name']}_write,
    .read = {peripheral['name']}_read,
    .llseek = {peripheral['name']}_llseek,
    .open = {peripheral['name']}_open,
    .release = {peripheral['name']}_release,
}};

static const struct of_device_id of_{peripheral['name']}_match[] = {{
    {{.compatible = "iobundle,{peripheral['instance_name']}"}},
    {{}},
}};

static struct platform_driver {peripheral['name']}_driver = {{
    .driver =
        {{
            .name = "{peripheral['name']}",
            .owner = THIS_MODULE,
            .of_match_table = of_{peripheral['name']}_match,
        }},
    .probe = {peripheral['name']}_probe,
    .remove = {peripheral['name']}_remove,
}};

//
// Module init and exit functions
//
static int {peripheral['name']}_probe(struct platform_device *pdev) {{
  struct resource *res;
  int result = 0;

  if ({peripheral['name']}_data.device != NULL) {{
    pr_err("[Driver] %s: No more devices allowed!\\n", {peripheral['upper_name']}_DRIVER_NAME);

    return -ENODEV;
  }}

  pr_info("[Driver] %s: probing.\\n", {peripheral['upper_name']}_DRIVER_NAME);

  // Get the I/O region base address
  res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
  if (!res) {{
    pr_err("[Driver]: Failed to get I/O resource!\\n");
    result = -ENODEV;
    goto r_get_resource;
  }}

  // Request and map the I/O region
  {peripheral['name']}_data.regbase = devm_ioremap_resource(&pdev->dev, res);
  if (IS_ERR({peripheral['name']}_data.regbase)) {{
    result = PTR_ERR({peripheral['name']}_data.regbase);
    goto r_ioremmap;
  }}
  {peripheral['name']}_data.regsize = resource_size(res);

  // Alocate char device
  result =
      alloc_chrdev_region(&{peripheral['name']}_data.devnum, 0, 1, {peripheral['upper_name']}_DRIVER_NAME);
  if (result) {{
    pr_err("%s: Failed to allocate device number!\\n", {peripheral['upper_name']}_DRIVER_NAME);
    goto r_alloc_region;
  }}

  cdev_init(&{peripheral['name']}_data.cdev, &{peripheral['name']}_fops);

  result = cdev_add(&{peripheral['name']}_data.cdev, {peripheral['name']}_data.devnum, 1);
  if (result) {{
    pr_err("%s: Char device registration failed!\\n", {peripheral['upper_name']}_DRIVER_NAME);
    goto r_cdev_add;
  }}

  // Create device class // todo: make a dummy driver just to create and own the
  // class: https://stackoverflow.com/a/16365027/8228163
  if (({peripheral['name']}_data.class =
           class_create(THIS_MODULE, {peripheral['upper_name']}_DRIVER_CLASS)) == NULL) {{
    printk("Device class can not be created!\\n");
    goto r_class;
  }}

  // Create device file
  {peripheral['name']}_data.device =
      device_create({peripheral['name']}_data.class, NULL, {peripheral['name']}_data.devnum, NULL,
                    {peripheral['upper_name']}_DRIVER_NAME);
  if ({peripheral['name']}_data.device == NULL) {{
    printk("Can not create device file!\\n");
    goto r_device;
  }}

  result = {peripheral['name']}_create_device_attr_files({peripheral['name']}_data.device);
  if (result) {{
    pr_err("Cannot create device attribute file......\\n");
    goto r_dev_file;
  }}

  dev_info(&pdev->dev, "initialized.\\n");
  goto r_ok;

r_dev_file:
  {peripheral['name']}_remove_device_attr_files(&{peripheral['name']}_data);
r_device:
  class_destroy({peripheral['name']}_data.class);
r_class:
  cdev_del(&{peripheral['name']}_data.cdev);
r_cdev_add:
  unregister_chrdev_region({peripheral['name']}_data.devnum, 1);
r_alloc_region:
  // iounmap is managed by devm
r_ioremmap:
r_get_resource:
r_ok:

  return result;
}}

static int {peripheral['name']}_remove(struct platform_device *pdev) {{
  {peripheral['name']}_remove_device_attr_files(&{peripheral['name']}_data);
  class_destroy({peripheral['name']}_data.class);
  cdev_del(&{peripheral['name']}_data.cdev);
  unregister_chrdev_region({peripheral['name']}_data.devnum, 1);
  // Note: no need for iounmap, since we are using devm_ioremap_resource()

  dev_info(&pdev->dev, "exiting.\\n");

  return 0;
}}

static int __init test_counter_init(void) {{
  pr_info("[Driver] %s: initializing.\\n", {peripheral['upper_name']}_DRIVER_NAME);

  return platform_driver_register(&{peripheral['name']}_driver);
}}

static void __exit test_counter_exit(void) {{
  pr_info("[Driver] %s: exiting.\\n", {peripheral['upper_name']}_DRIVER_NAME);
  platform_driver_unregister(&{peripheral['name']}_driver);
}}

//
// File operations
//

static int {peripheral['name']}_open(struct inode *inode, struct file *file) {{
  pr_info("[Driver] {peripheral['name']} device opened\\n");

  if (!mutex_trylock(&{peripheral['name']}_mutex)) {{
    pr_info("Another process is accessing the device\\n");

    return -EBUSY;
  }}

  return 0;
}}

static int {peripheral['name']}_release(struct inode *inode, struct file *file) {{
  pr_info("[Driver] {peripheral['name']} device closed\\n");

  mutex_unlock(&{peripheral['name']}_mutex);

  return 0;
}}

static ssize_t {peripheral['name']}_read(struct file *file, char __user *buf, size_t count,
                              loff_t *ppos) {{
  int size = 0;
  u32 value = 0;

  /* read value from register */
  switch (*ppos) {{
"""
    # Create read code for each CSR
    for csr in peripheral["csrs"]:
        if "R" not in csr["mode"]:
            continue
        CSR_NAME = csr["name"].upper()
        content += f"""\
  case {peripheral['upper_name']}_{CSR_NAME}_ADDR:
    value = iob_data_read_reg({peripheral['name']}_data.regbase, {peripheral['upper_name']}_{CSR_NAME}_ADDR,
                              {peripheral['upper_name']}_{CSR_NAME}_W);
    size = ({peripheral['upper_name']}_{CSR_NAME}_W >> 3); // bit to bytes
    pr_info("[Driver] Read {csr['name']} CSR!\\n");
    break;
"""

    content += f"""\
  default:
    // invalid address - no bytes read
    return 0;
  }}

  // Read min between count and REG_SIZE
  if (size > count)
    size = count;

  if (copy_to_user(buf, &value, size))
    return -EFAULT;

  return count;
}}

static ssize_t {peripheral['name']}_write(struct file *file, const char __user *buf,
                               size_t count, loff_t *ppos) {{
  int size = 0;
  u32 value = 0;

  switch (*ppos) {{
"""
    # Create write code for each CSR
    for csr in peripheral["csrs"]:
        if "W" not in csr["mode"]:
            continue
        CSR_NAME = csr["name"].upper()
        content += f"""\
  case {peripheral['upper_name']}_{CSR_NAME}_ADDR:
    size = ({peripheral['upper_name']}_{CSR_NAME}_W >> 3); // bit to bytes
    if (read_user_data(buf, size, &value))
      return -EFAULT;
    iob_data_write_reg({peripheral['name']}_data.regbase, value, {peripheral['upper_name']}_{CSR_NAME}_ADDR,
                       {peripheral['upper_name']}_{CSR_NAME}_W);
    pr_info("[Driver] {csr['name']} {peripheral['name']}: 0x%x\\n", value);
    break;
"""

    content += f"""\
  default:
    pr_info("[Driver] Invalid write address 0x%x\\n", (unsigned int)*ppos);
    // invalid address - no bytes written
    return 0;
  }}

  return count;
}}

/* Custom lseek function
 * check: lseek(2) man page for whence modes
 */
static loff_t {peripheral['name']}_llseek(struct file *filp, loff_t offset, int whence) {{
  loff_t new_pos = -1;

  switch (whence) {{
  case SEEK_SET:
    new_pos = offset;
    break;
  case SEEK_CUR:
    new_pos = filp->f_pos + offset;
    break;
  case SEEK_END:
    new_pos = (1 << {peripheral['upper_name']}_CSRS_ADDR_W) + offset;
    break;
  default:
    return -EINVAL;
  }}

  // Check for valid bounds
  if (new_pos < 0 || new_pos > {peripheral['name']}_data.regsize) {{
    return -EINVAL;
  }}

  // Update file position
  filp->f_pos = new_pos;

  return new_pos;
}}

module_init(test_counter_init);
module_exit(test_counter_exit);

MODULE_LICENSE("{peripheral['license']}");
MODULE_AUTHOR("{peripheral['author']}");
MODULE_DESCRIPTION("{peripheral['description']}");
MODULE_VERSION("{peripheral['version']}");
"""
    with open(os.path.join(path, f"{peripheral['name']}_main.c"), "w") as f:
        f.write(content)


def create_user_c_file(path, peripheral):
    """Create user-space C file to interact with the driver"""
    content = f"""/*
 * SPDX-FileCopyrightText: {peripheral['spdx_year']} {peripheral['author']}
 *
 * SPDX-License-Identifier: {peripheral['spdx_license']}
 */

#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "{peripheral['name']}.h"

int sysfs_read_file(const char *filename, uint32_t *read_value) {{
  // Open file for read
  FILE *file = fopen(filename, "r");
  if (file == NULL) {{
    perror("[User] Failed to open the file");
    return -1;
  }}

  // Read uint32_t value from file in ASCII
  ssize_t ret = fscanf(file, "%u", read_value);
  if (ret == -1) {{
    perror("[User] Failed to read from file");
    fclose(file);
    return -1;
  }}

  fclose(file);

  return ret;
}}

int sysfs_write_file(const char *filename, uint32_t write_value) {{
  // Open file for write
  FILE *file = fopen(filename, "w");
  if (file == NULL) {{
    perror("[User] Failed to open the file");
    return -1;
  }}

  // Write uint32_t value to file in ASCII
  ssize_t ret = fprintf(file, "%u", write_value);
  if (ret == -1) {{
    perror("[User] Failed to write to file");
    fclose(file);
    return -1;
  }}

  fclose(file);

  return ret;
}}

int timer_reset() {{
  if (sysfs_write_file({peripheral['upper_name']}_SYSFILE_RESET, 1) == -1) {{
    return -1;
  }}
  if (sysfs_write_file({peripheral['upper_name']}_SYSFILE_RESET, 0) == -1) {{
    return -1;
  }}

  return 0;
}}

int timer_init() {{
  if (timer_reset()) {{
    return -1;
  }}

  if (sysfs_write_file({peripheral['upper_name']}_SYSFILE_ENABLE, 1) == -1) {{
    return -1;
  }}

  return 0;
}}

int timer_print_version() {{
  uint32_t ret = -1;
  uint32_t version = 0;

  ret = sysfs_read_file({peripheral['upper_name']}_SYSFILE_VERSION, &version);
  if (ret == -1) {{
    return ret;
  }}

  printf("[User] Version: 0x%x\\n", version);
  return 0;
}}

int timer_get_count(uint64_t *count) {{
  uint32_t ret = -1;
  uint32_t data = 0;

  // Sample timer counter
  if (sysfs_write_file({peripheral['upper_name']}_SYSFILE_SAMPLE, 1) == -1) {{
    return -1;
  }}
  if (sysfs_write_file({peripheral['upper_name']}_SYSFILE_SAMPLE, 0) == -1) {{
    return -1;
  }}

  // Read sampled timer counter
  ret = sysfs_read_file({peripheral['upper_name']}_SYSFILE_DATA_HIGH, &data);
  if (ret == -1) {{
    return -1;
  }}
  *count = ((uint64_t)data) << {peripheral['upper_name']}_DATA_LOW_W;
  ret = sysfs_read_file({peripheral['upper_name']}_SYSFILE_DATA_LOW, &data);
  if (ret == -1) {{
    return -1;
  }}
  (*count) = (*count) | (uint64_t)data;

  return 0;
}}

int main(int argc, char *argv[]) {{
  printf("[User] IOb-Timer application\\n");

  if (timer_init()) {{
    perror("[User] Failed to initialize timer");

    return EXIT_FAILURE;
  }}

  if (timer_print_version()) {{
    perror("[User] Failed to print version");

    return EXIT_FAILURE;
  }}

  // read current timer count
  uint64_t elapsed = 0;
  if (timer_get_count(&elapsed)) {{
    perror("[User] Failed to get count");
  }}
  printf("\\nExecution time: %lu clock cycles\\n", elapsed);

  return EXIT_SUCCESS;
}}
"""
    with open(os.path.join(path, f"{peripheral['name']}_user.c"), "w") as f:
        f.write(content)


def create_user_makefile(path, peripheral):
    """Create Makefile to build user application"""
    content = f"""# SPDX-FileCopyrightText: {peripheral['spdx_year']} {peripheral['author']}
#
# SPDX-License-Identifier: {peripheral['spdx_license']}

SRC = $(wildcard *.c)
HDR += {peripheral['name']}.h
FLAGS = -Wall -Werror -O2
FLAGS += -static
FLAGS += -march=rv32imac
FLAGS += -mabi=ilp32
BIN = {peripheral['name']}_user
CC = riscv64-unknown-linux-gnu-gcc

all: $(BIN)

$(BIN): $(SRC) $(HDR)
	$(CC) $(FLAGS) $(INCLUDE) -o $(BIN) $(SRC)

LIB_DIR = ../../../../../../
IOB_LINUX_DIR ?= ../../../lib/iob-linux
$(HDR):
	cd lib && \\
		.$(IOB_LINUX_DIR)/scripts/drivers.py {peripheral['name']} -o `realpath $(CURDIR)`

clean:
	rm -rf $(BIN) $(HDR)
"""
    with open(os.path.join(path, "Makefile"), "w") as f:
        f.write(content)


def generate_device_drivers(output_dir, peripheral):
    """Generate device driver files for a peripheral"""

    # Find 'iob_csrs' subblock
    for block in peripheral["subblocks"]:
        if block["core_name"] == "iob_csrs":
            csrs_subblock = block
            break
    else:
        print("Error: no iob_csrs subblock found")
        exit(1)

    # Create copy of csrs list
    csrs_list = list(csrs_subblock["csrs"])
    # Every peripheral has an implicit "version" CSR
    csrs_list.append(
        {
            "name": "version",
            "mode": "R",
            "n_bits": 16,
        }
    )

    # Peripheral information
    # TODO: Replace hardcoded by dynamic info.
    _peripheral = {
        "name": peripheral["name"],  # example: 'iob_timer'
        "instance_name": f"{peripheral['name'][4:]}0",  # example: 'timer0'
        "upper_name": peripheral["name"].upper(),
        "version": "0.81",
        "description": f"{peripheral['name']} Drivers",
        "author": "IObundle",
        "spdx_year": "2025",
        "spdx_license": "MIT",
        "license": "Dual MIT/GPL",
        "csrs": csrs_list,
    }

    print("Generating device drivers for", _peripheral["name"], "in", output_dir)

    # Create directory structure
    os.makedirs(os.path.join(output_dir, "drivers"), exist_ok=True)
    os.makedirs(os.path.join(output_dir, "user"), exist_ok=True)

    # Create files
    create_dts_file(output_dir, _peripheral)
    create_readme_file(output_dir, _peripheral)
    create_driver_mk_file(os.path.join(output_dir, "drivers"), _peripheral)
    create_driver_main_file(os.path.join(output_dir, "drivers"), _peripheral)
    create_user_c_file(os.path.join(output_dir, "user"), _peripheral)
    create_user_makefile(os.path.join(output_dir, "user"), _peripheral)
